#include <stdio.h>

#include <stdbool.h>

#include<stdlib.h>


struct coordinate {

  int x;
  int y;

};

bool checkIfQuad(struct coordinate quad[4]) {

  //2,5 15,5 15,5 2,5
  for (int h = 0; h < 4; h++) {

    struct coordinate bank[3];

    for (int left = 0; left < h; left++) {
      bank[left] = quad[left];
    }

    for (int right = h + 1; right < 4; right++) {
      bank[right - 1] = quad[right];
    }

    for (int check = 0; check < 3; check++) {
      int xCheck = 0;
      int yCheck = 0;
      if (quad[h].x == bank[check].x && quad[h].y == bank[check].y) {
        return false;
        break;
      }
      if (quad[h].x == bank[check].x) {
        xCheck++;
      }
      if (quad[h].y == bank[check].y) {
        yCheck++;
      }
      if (xCheck == 2) {
        return false;
        break;
      }
      if (yCheck == 2) {
        return false;
        break;
      }
    }

  }

  return true;

}

bool check(struct coordinate snap[4]) {

  if (snap[0].x == snap[3].x && snap[0].y == snap[1].y && snap[1].x == snap[2].x && snap[2].y == snap[3].y) {
    return true;
  }

  return false;

}

struct coordinate * dissect(struct coordinate snap[4]) {

  static struct coordinate output[4];
  struct coordinate xMaxR;
  struct coordinate finalBankR[2];

  xMaxR = snap[0];

  for (int i = 1; i < 4; i++) {

    if (snap[i].x > xMaxR.x) {
      xMaxR = snap[i];

    } else if (snap[i].x == xMaxR.x) {
      finalBankR[0] = snap[i];

    }

  }

  finalBankR[1] = xMaxR;

  if (finalBankR[1].y > finalBankR[0].y) {

    output[1] = finalBankR[1];
    output[2] = finalBankR[0];

  } else {

    output[1] = finalBankR[0];
    output[2] = finalBankR[1];

  }

  struct coordinate xMinL;
  struct coordinate finalBankL[2];

  xMinL = snap[0];

  for (int t = 1; t < 4; t++) {

    if (snap[t].x < xMinL.x) {
      xMinL = snap[t];

    } else if (snap[t].x == xMinL.x) {
      finalBankL[0] = snap[t];

    }

  }

  finalBankL[1] = xMinL;

  if (finalBankL[1].y < finalBankL[0].y) {

    output[3] = finalBankL[1];
    output[0] = finalBankL[0];

  } else {

    output[3] = finalBankL[0];
    output[0] = finalBankL[1];

  }

  return output;

}

int main(void) {

  void algorithm();
  char junk[10];
  char agsCode[4];
  agsCode[3] = '\0';
  bool compiledCode[3];
  int count = 0;

  printf("Welcome to the CompetitiveProgrammingMath-RectangleParty, where you will go through a SUPER ADVANCED ALGORITHM.\nThis algorithm will take in an n ammount of coordinates, and calculate how many rectangles you can make that are parallel to the X or Y axis with these coordinates.\n");
  printf("Are you ready for your adventure?\n");
  fscanf(stdin, "%s", junk);
  printf("Bahaha I dont care! Of course you are!\n");
  printf("The least amount of coordinates you can computate are four.\n");
  printf("Please give me the number of coordinates you want to input : ");
  scanf("%i", & count);
  if (count >= 4) {

    printf("Press any key and enter to continue : ");
    fscanf(stdin, "%1s", junk);
    printf("\n");
    printf("Now, here is a short operation manual on this advanced algorithm.\n");
    printf("Press any key and enter to continue : ");
    fscanf(stdin, "%1s", junk);
    printf("\n");
    printf("To see what is going on in the inside of the algorithm, I (HypeByte) have made algorithm streams.\n");
    printf("Press any key and enter to continue : ");
    fscanf(stdin, "%1s", junk);
    printf("\n");
    printf("There are three algorithm streams:\n");
    printf("The first algorithm stream shows you the rectangles being generated by the algorithm.\n");
    printf("The generator makes every single combination of four coordinates with the given points.\n");
    printf("Unlocking this stream can be a bad idea for a large ammount of coordinates.\n");
    printf("Your terminal can get overflowed, and if it does, do ctrl + c to exit out.\n");
    printf("Press any key and enter to continue : ");
    fscanf(stdin, "%1s", junk);
    printf("\n");
    printf("The second algorithm stream shows you any rectangles that have passed the test.\n");
    printf("Remember, if a rectangle ABCD passes the test and ACDB comes, which is the same, ACBD will fail.\n");
    printf("Making the same rectangles be able to be counted will have a huge accuracy flaw.\n");
    printf("Press any key and enter to continue : ");
    fscanf(stdin, "%1s", junk);
    printf("\n");
    printf("The third algorithm stream shows you any rectangles that have failed the test.\n");
    printf("By fail test, I mean the clone test.\n");
    printf("The clone test is an advanced system that find rectangles that have already been marked, and not let them pass.\n");
    printf("Press any key and enter to continue : ");
    fscanf(stdin, "%1s", junk);
    printf("\n");
    printf("Now, to unlock and lock algorithm streams, you will be asked for a three digit number.\n");
    printf("This three digit number only uses the digits 1 and 0.\n");
    printf("Two examples are 101 and 110\n");
    printf("Starting at the leftmost digit, each digit maps to an algorithm stream.\n");
    printf("For example in the code 101, 1 maps to the first algorithm stream, 0 to the second, 1 to the third.\n");
    printf("1 represents unlock, 0 represents lock.\n");
    printf("Press any key and enter to continue : ");
    fscanf(stdin, "%1s", junk);
    printf("\n");
    printf("If you want more algorithm streams, here are steps to do that:\n");
    printf("1: Go to this github repository --> https://github.com/HypeByte/CompetitiveProgrammingMath-RectangleParty\n");
    printf("2: Go to the issues tab.\n");
    printf("3: Hit the green button at the top right that says new issue.\n");
    printf("4: On the right, click on the labels button and choose the label enhancement.\n");
    printf("5: Describe your algorithm stream you want and I will try to do it ASAP.\n");
    printf("Remember, algorithm streams are a way to see what is going on inside the algorithm.\n");
    printf("If there are any bugs, please report.\n");
    printf("If you have any questions, you can ask them by using the question label.\n");
    printf("Press any key and enter to continue : ");
    fscanf(stdin, "%1s", junk);
    printf("\n");

    printf("Now, enter a three digit code to specify the algorithm stream setting : ");
    scanf("%3s", agsCode);
    printf("%s\n", agsCode);

    for (int e = 0; e < 3; e++) {
      compiledCode[e] = agsCode[e] == '1' ? true : false;
    }

    printf("Mhm, START THE ALGORITHM\n");
  } else {
    printf("Too less coordinates, abort!\n");
    printf("Ram : phewww!\n");
    return 1;
  }
  printf("Ram : Uh oh..\n");
  algorithm(count, compiledCode);

}

void algorithm(int coords, bool * algStreams) {
  bool firstCheck = false;
  bool checkInfo;
  int sum = 0;
  int rectPos = 1;
  struct coordinate trueBank[100][4];
  struct coordinate input[coords];

  for (int i = 0, n = -1; i < coords * 2; i++) {
    n += i % 2 == 0 ? 1 : 0;
    i % 2 == 0 ? printf("Enter X value for coordinate %i : ", n) : printf("Enter Y value for coordinate %i : ", n);
    i % 2 == 0 ? scanf("%i", & (input[n].x)) : scanf("%i", & (input[n].y));

  }

  struct coordinate col1[coords - 1];
  struct coordinate col2[coords - 1];
  struct coordinate col3[coords - 1];
  struct coordinate quadSnap[4];

  for (int i = 0; i < coords; i++) {

    for (int left = 0; left < i; left++) {
      col1[left] = input[left];
      col2[left] = input[left];
      col3[left] = input[left];
    }

    for (int right = i + 1; right < coords; right++) {
      col1[right - 1] = input[right];
      col2[right - 1] = input[right];
      col3[right - 1] = input[right];
    }

    for (int Icol1 = 0, Icol2 = 0, Icol3 = 0; Icol1 < coords - 1; Icol3++) {

      if (Icol3 == coords - 1) {
        Icol3 = 0;
        Icol2++;

      }

      if (Icol2 == coords - 1) {
        Icol2 = 0;
        Icol1++;
      }

      if (Icol1 == coords - 1) {
        break;
      }

      if (Icol3 == Icol2 || Icol2 == Icol1 || Icol3 == Icol1) {
        continue;
      }

      quadSnap[0] = input[i];
      quadSnap[1] = col1[Icol1];
      quadSnap[2] = col2[Icol2];
      quadSnap[3] = col3[Icol3];
      if (algStreams[0]) {
        printf("Rectangle generated: (%i,%i) (%i,%i) (%i,%i) (%i,%i)\n", quadSnap[0].x, quadSnap[0].y, quadSnap[1].x, quadSnap[1].y, quadSnap[2].x, quadSnap[2].y, quadSnap[3].x, quadSnap[3].y);
      }
      if (checkIfQuad(quadSnap)) {

        struct coordinate * memSnap = dissect(quadSnap);
        if (checkIfQuad(memSnap)) {

          if (check(memSnap)) {

            if (rectPos == 1 && firstCheck == false) {
              trueBank[0][0].x = memSnap -> x;
              trueBank[0][0].y = memSnap -> y;
              trueBank[0][1].x = (memSnap + 1) -> x;
              trueBank[0][1].y = (memSnap + 1) -> y;
              trueBank[0][2].x = (memSnap + 2) -> x;
              trueBank[0][2].y = (memSnap + 2) -> y;
              trueBank[0][3].x = (memSnap + 3) -> x;
              trueBank[0][3].y = (memSnap + 3) -> y;
              if (algStreams[1]) {
                printf("First true triangle of the day! (%i,%i) (%i,%i) (%i,%i) (%i,%i)\n", memSnap -> x, memSnap -> y, (memSnap + 1) -> x, (memSnap + 1) -> y, (memSnap + 2) -> x, (memSnap + 2) -> y, (memSnap + 3) -> x, (memSnap + 3) -> y);
              }
              firstCheck = true;
              sum++;
            } else {

              for (int b = 0; b < rectPos; b++) {

                if (memSnap -> x == trueBank[b][0].x && memSnap -> y == trueBank[b][0].y && (memSnap + 1) -> x == trueBank[b][1].x && (memSnap + 1) -> y == trueBank[b][1].y && (memSnap + 2) -> x == trueBank[b][2].x && (memSnap + 2) -> y == trueBank[b][2].y && (memSnap + 3) -> x == trueBank[b][3].x && (memSnap + 3) -> y == trueBank[b][3].y) {

                  checkInfo = false;
                  break;
                  if (algStreams[2]) {
                    printf("False.. (%i,%i) (%i,%i) (%i,%i) (%i,%i)\n", memSnap -> x, memSnap -> y, (memSnap + 1) -> x, (memSnap + 1) -> y, (memSnap + 2) -> x, (memSnap + 2) -> y, (memSnap + 3) -> x, (memSnap + 3) -> y);
                  }

                } else if (b == (rectPos - 1)) {

                  checkInfo = true;
                  if (algStreams[1]) {
                    printf("First true triangle of the day! (%i,%i) (%i,%i) (%i,%i) (%i,%i)\n", memSnap -> x, memSnap -> y, (memSnap + 1) -> x, (memSnap + 1) -> y, (memSnap + 2) -> x, (memSnap + 2) -> y, (memSnap + 3) -> x, (memSnap + 3) -> y);
                  }

                }

              }

              if (checkInfo) {

                trueBank[rectPos][0].x = memSnap -> x;
                trueBank[rectPos][0].y = memSnap -> y;
                trueBank[rectPos][1].x = (memSnap + 1) -> x;
                trueBank[rectPos][1].y = (memSnap + 1) -> y;
                trueBank[rectPos][2].x = (memSnap + 2) -> x;
                trueBank[rectPos][2].y = (memSnap + 2) -> y;
                trueBank[rectPos][3].x = (memSnap + 3) -> x;
                trueBank[rectPos][3].y = (memSnap + 3) -> y;
                if (algStreams[1]) {
                  printf("True.. (%i,%i) (%i,%i) (%i,%i) (%i,%i)\n", memSnap -> x, memSnap -> y, (memSnap + 1) -> x, (memSnap + 1) -> y, (memSnap + 2) -> x, (memSnap + 2) -> y, (memSnap + 3) -> x, (memSnap + 3) -> y);
                }
                rectPos++;
                sum++;

              }

            }

          }

        }

      }

    }

  }

  printf("Number of rectangles that meet the constraint are %i\n", sum);

}